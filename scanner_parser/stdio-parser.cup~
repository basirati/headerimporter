
import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:
   
	public CodeGenerator cg = new CodeGenerator();

    public void report_error(String message, Object info) {
   
       
        StringBuilder m = new StringBuilder("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
     
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {                
                       m.append(" in line "+(s.left+1));   
     
                if (s.right >= 0)                    
                       m.append(", column "+(s.right+1));
            }
        }
   
        m.append(" : "+message);
   
        System.err.println(m);
    }
   
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};
   


terminal		DEFINE, LBRACKET, RBRACKET, ASSIGN, DOT, DOTS, BAR, BARDOT, GREATER, LESS, GG, LL, PREF, MM, PP, GE, LE, AND, OR, NOTEQUAL, EQUAL, COLON, SEMI, PLUS, MINUS, STAR, DIVIDE, COMMA, LPAREN, RPAREN, EXTERN, TYPEDEF, STRUCT, LQ, RQ, PERCENT, HAT, QUESTIONMARK, SHORT, LONG, UN_SIGNED, CONST, AMPERSAND, TILDE, CHAR, INT, SINT, LINT, LLONG, LLINT, FLOAT, DOUBLE, LDOUBLE, PLUSEQ, MINUSEQ, STAREQ, DIVIDEQ, PERCENTEQ, LLEQ, GGEQ, AMPERSANDEQ, HATEQ, BAREQ;

terminal Integer	NUMBER;
terminal String		ID;
   
non terminal Object     def_body, program, code_part, params, defin, st_body, func, ident_funcpointer, exp, func_call, args, Ar2, B2, LogicalS, macro_params, def_val;
non terminal String	type, pre_type, c_type;

precedence left ASSIGN, PLUSEQ, MINUSEQ, STAREQ, DIVIDEQ, PERCENTEQ, LLEQ, GGEQ, AMPERSANDEQ, HATEQ, BAREQ;
precedence left QUESTIONMARK, COLON;
precedence left AND, OR;
precedence left	BAR, HAT;
precedence left LESS, LE, GREATER, GE, EQUAL, NOTEQUAL;
precedence left LL, GG;
precedence left PLUS, MINUS;
precedence left DIVIDE, PERCENT;
precedence left STAR, AMPERSAND;
precedence left BARDOT, TILDE;
precedence left DOT, PREF;
precedence left LBRACKET, RBRACKET;
precedence left PP, MM;
precedence left LPAREN, RPAREN;
precedence left ID;
   
	program	::=	program code_part
				|
				code_part
				;

   
	code_part ::= 	EXTERN func:f SEMI
			{: parser.cg.declareFunc(); :}
			|
			EXTERN defin:d SEMI
			{: parser.cg.declareVar(); :}
			|
			TYPEDEF defin:d2 SEMI
			{: parser.cg.declareTypedef_var(); :}
			|
			TYPEDEF STRUCT LQ st_body:s RQ ID:i SEMI
			{: parser.cg.declareTypedef_struct(i); :}
			|
			STRUCT ID:i LQ st_body:s RQ SEMI
			{: 
			parser.cg.struct.setID(i);
			parser.cg.declareStruct(); 
			:}
			|
			DEFINE def_body
			;


	def_body	::=
			ID:i def_val:v
			{: 
			parser.cg.declareDefine(i, "", v, false);
			:}
			|
			ID:i LPAREN macro_params:m RPAREN exp:e
			{:
			parser.cg.declareDefine(i, "("+m+")", e, false);
			:}
			|
			ID:i STRUCT ID:v
			{:
			parser.cg.declareDefine(i, "", v, true);			
			:}
			;
	
	def_val ::=	NUMBER:n {: RESULT = n; :} | func_call:f {: RESULT = f; :} 
			| def_val:d LBRACKET exp:e RBRACKET {: RESULT = d+"["+e+"]"; :}  | def_val:d DOT func_call:f {: RESULT = d+"."+f; :} 
			| def_val:d DOT ID:i {: RESULT = d+"."+i; :} 
			| def_val:d PREF func_call:f {: RESULT = d+"->"+f; :} | def_val:d PREF ID:i {: RESULT = d+"->"+i; :} 
			| def_val:d PP {: RESULT = d+"++"; :} | def_val:d MM {: RESULT = d+"--"; :} 
			| MINUS exp:e {: RESULT = "-"+e; :} | PLUS exp:e {: RESULT = "+"+e; :} 
			| PP exp:e {: RESULT = "++"+e; :} | MM exp:e {: RESULT = "++"+e; :} 
			| STAR exp:e {: RESULT = "*"+e; :} | AMPERSAND exp:e {: RESULT = "&"+e; :} 
			| def_val:d Ar2:o exp:e {: RESULT = d + " " + e + " " + o; :} 
			| def_val:d B2:o exp:e {: RESULT = d + " " + e + " " + o; :} 
			| def_val:d LogicalS:o exp:e {: RESULT = d + " " + e + " " + o; :} 
			| def_val:d QUESTIONMARK exp:e1 COLON exp:e2 {: RESULT = " ? "+d+" "+e1+" "+e2; :} 
			| BARDOT exp:e {: RESULT = "!"+e; :} 
			| TILDE exp:e {: RESULT = "~"+e; :} 
			| LPAREN def_val:d RPAREN {: RESULT = "("+d+")"; :} 
			;
	
	exp ::=		NUMBER:n {: RESULT = n; :} | ID:i {: RESULT = i; :} | func_call:f {: RESULT = f; :}
			| exp:e LBRACKET exp:e2 RBRACKET {: RESULT = e+"["+e2+"]"; :} | exp:e DOT func_call:f {: RESULT = e+"."+f; :}
			| exp:e DOT ID:i {: RESULT = e+"."+i; :}
			| exp:e PREF func_call:f {: RESULT = e+"->"+f; :} | exp:e PREF ID:i {: RESULT = e+"->"+i; :}
			| exp:e PP {: RESULT = e+"++"; :} | exp:e MM {: RESULT = e+"--"; :}
			| MINUS exp:e {: RESULT = "-"+e; :} | PLUS exp:e {: RESULT = ""+e; :}
			| PP exp:e {: RESULT = "++"+e; :} | MM exp:e {: RESULT = "--"+e; :}
			| STAR exp:e {: RESULT = "*"+e; :} | AMPERSAND exp:e {: RESULT = "&"+e; :}
			| exp:e Ar2:o exp:e2 {: RESULT = e + " " + e2 + " " + o; :}
			| exp:e B2:o exp:e2 {: RESULT = e + " " + e2 + " " + o; :}
			| exp:e LogicalS:o exp:e2 {: RESULT = e + " " + e2 + " " + o; :}
			| exp:e QUESTIONMARK exp:e1 COLON exp:e2 {: RESULT = " ? " + e + " " + e1 +" "+e2; :}
			| BARDOT exp:e {: RESULT = "!"+e; :}
			| TILDE exp:e {: RESULT = "~"+e; :}
			| LPAREN exp:e RPAREN {: RESULT = "("+e+")"; :}
			;

	Ar2 ::=		ASSIGN {: RESULT = "="; :} | DIVIDE {: RESULT = "/"; :} | PERCENT {: RESULT = "%"; :} 
			| PLUS {: RESULT = "+"; :} | MINUS {: RESULT = "-"; :}
			| AMPERSAND ASSIGN {: RESULT = "&="; :}
			| PLUSEQ {: RESULT = "+="; :} | MINUSEQ {: RESULT = "-="; :}
			| STAREQ {: RESULT = "*="; :} | DIVIDEQ {: RESULT = "/="; :}
			| PERCENTEQ {: RESULT = "%="; :} | LLEQ {: RESULT = "<<="; :} | GGEQ {: RESULT = ">>="; :} 
			| AMPERSANDEQ {: RESULT = "&="; :} | HATEQ {: RESULT = "^="; :} | BAREQ {: RESULT = "|="; :}
			;
	B2 ::=		LL {: RESULT = "<<"; :} | GG {: RESULT = ">>"; :} 
			| HAT {: RESULT = "^"; :} | BAR {: RESULT = "|"; :} | AMPERSAND {: RESULT = "&"; :}
			;
	LogicalS ::=	LESS {: RESULT = "<"; :} | LE {: RESULT = "<="; :} 
			| GREATER {: RESULT = ">"; :} | GE {: RESULT = ">="; :} 
			| EQUAL {: RESULT = "=="; :} | NOTEQUAL {: RESULT = "!="; :} 
			| AND {: RESULT = "&&"; :} | OR {: RESULT = "||"; :}
			; 
	func_call ::=	ID:i LPAREN args:a RPAREN {:RESULT = i+"("+a+")"; :}| ID:i LPAREN RPAREN {:RESULT = i+"()"; :};
	args ::=	args:a COMMA exp:e {:RESULT = a+","+e; :}| exp:e {:RESULT = e; :};

	macro_params ::=macro_params:m COMMA ID:i {:RESULT = m+","+i; :}| ID:i {:RESULT = i; :} | {:RESULT = ""; :};

	func	::=	type:e ID:e2 LPAREN 
			{: 
			parser.cg.func.setReturn_type(e);
			parser.cg.func.setID(e2);
			parser.cg.paramsowner = parser.cg.func;
			:}						
			params:p RPAREN
			{: 
			RESULT = e + " " + e2 + "(" + p + ");"; 
			:} 
			;
	

	st_body	::=	defin SEMI
			{:
			parser.cg.struct.addMember(parser.cg.var);
		        parser.cg.var = new Variable(); 
			:}
			|
			st_body:s defin SEMI
			{:
			parser.cg.struct.addMember(parser.cg.var);
		        parser.cg.var = new Variable();  
			:}
			;
	
	defin ::=	type:i ID:i2
			{: 
			parser.cg.var.setType(i);
			parser.cg.var.setID(i2);
			:}
			|
			defin LBRACKET RBRACKET
			{:
			parser.cg.var.addArray(0);
			:}
			| 
			defin LBRACKET NUMBER:n RBRACKET
			{:
			parser.cg.var.addArray(n);
			:}
			|
			type:i7 LPAREN STAR ID:i8 RPAREN LPAREN
			{: 
			parser.cg.var.setType(i7+"*");
			parser.cg.var.setID(i8);
			Function funcp = new Function();
			funcp.setID(i8);
			funcp.setReturn_type(i7+"*");
			parser.cg.params_owners.push(parser.cg.paramsowner);
			parser.cg.paramsowner = funcp;  
			:}
			params:ps RPAREN
			{:
			Function funcp = parser.cg.paramsowner;
			funcp.pointer = true;
			parser.cg.var.setFuncpointer(funcp);
			parser.cg.paramsowner = parser.cg.params_owners.pop();
			:}
			;

	

	params	::=	type: p
			{: 
			parser.cg.paramsowner.pushParam(p);
			:}
			|
			type:p2 COMMA params:ps
			{: 
			parser.cg.paramsowner.pushParam(p2);
			:}
			|
			type:p3 COMMA DOTS
			{:
			parser.cg.paramsowner.pushParam(p3);
			:}
			|
			ident_funcpointer:p4
			{:
			parser.cg.paramsowner.pushParam(p4);
			:}
			|
			ident_funcpointer:p5 COMMA params:ps2
			{: 
			parser.cg.paramsowner.pushParam(p5);
			:}
			|
			;

	ident_funcpointer ::=
			type:p4 LPAREN STAR RPAREN LPAREN 
			{:
			Function funcp = new Function();
			funcp.pointer = true;
			funcp.setReturn_type(p4);
			parser.cg.params_owners.push(parser.cg.paramsowner);
			parser.cg.paramsowner = funcp;  
			:}
			params:ps2 RPAREN
			{:
			Function funcp = parser.cg.paramsowner;
			funcp.pointer = true;
			parser.cg.paramsowner = parser.cg.params_owners.pop();
			RESULT = funcp;
			:}
			;



	c_type ::=	CHAR {: RESULT= "char"; :}| INT {: RESULT= "int"; :}
			| SINT {: RESULT= "short int"; :}| LINT {: RESULT= "long int"; :} 
			| SHORT {: RESULT="short"; :}
			| LONG {: RESULT="long"; :} | LLONG {: RESULT= "long long"; :}| LLINT {: RESULT= "long long int"; :}
			| FLOAT {: RESULT= "float"; :}| DOUBLE {: RESULT= "double"; :}| LDOUBLE {: RESULT= "long double"; :};
			
	pre_type::=	c_type:c {: RESULT= c; :}| ID:i {: RESULT= i; :}
			| STRUCT ID:i {: RESULT= "struct " + i; :}
			| UN_SIGNED:u pre_type:p {: RESULT= u + " " + p; :} 
			| CONST pre_type:p {: RESULT="const " + p; :};
			

	type::=		pre_type:p {: RESULT= p; :}
			| type:t LBRACKET RBRACKET {: RESULT=t + "[]"; :}
			| type:t LBRACKET NUMBER:n RBRACKET {: RESULT=t + "[" + n + "]"; :}
			| type:t STAR {: RESULT=t + "*"; :};

	




