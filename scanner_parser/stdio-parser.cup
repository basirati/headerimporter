
import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:
   
	public CodeGenerator cg = new CodeGenerator();

    public void report_error(String message, Object info) {
   
       
        StringBuilder m = new StringBuilder("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
     
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {                
                       m.append(" in line "+(s.left+1));   
     
                if (s.right >= 0)                    
                       m.append(", column "+(s.right+1));
            }
        }
   
        m.append(" : "+message);
   
        System.err.println(m);
    }
   
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};
   


terminal		DEFINE, LBRACKET, RBRACKET, ASSIGN, DOT, DOTS, BAR, BARDOT, GREATER, LESS, GG, LL, PREF, MM, PP, GE, LE, AND, OR, NOTEQUAL, EQUAL, COLON, SEMI, PLUS, MINUS, STAR, DIVIDE, COMMA, LPAREN, RPAREN, EXTERN, TYPEDEF, STRUCT, LQ, RQ, PERCENT, HAT, QUESTIONMARK, SHORT, LONG, UN_SIGNED, CONST, AMPERSAND, TILDE, CHAR, INT, SINT, LINT, LLONG, LLINT, FLOAT, DOUBLE, LDOUBLE, PLUSEQ, MINUSEQ, STAREQ, DIVIDEQ, PERCENTEQ, LLEQ, GGEQ, AMPERSANDEQ, HATEQ, BAREQ, IFDEF, IFNDEF, ELSE, ENDIF, INCLUDE;

terminal Integer	NUMBER;
terminal String		ID;
   
non terminal Object     def_body, program, code_part, params, definition, struct_body, func, ident_funcpointer, exp, func_call, args, Ar2, B2, LogicalS, macro_params, def_val, ConditionKeys;
non terminal String	type, pre_type, c_type;

precedence left ASSIGN, PLUSEQ, MINUSEQ, STAREQ, DIVIDEQ, PERCENTEQ, LLEQ, GGEQ, AMPERSANDEQ, HATEQ, BAREQ;
precedence left QUESTIONMARK, COLON;
precedence left AND, OR;
precedence left	BAR, HAT;
precedence left LESS, LE, GREATER, GE, EQUAL, NOTEQUAL;
precedence left LL, GG;
precedence left PLUS, MINUS;
precedence left DIVIDE, PERCENT;
precedence left STAR, AMPERSAND;
precedence left BARDOT, TILDE;
precedence left DOT, PREF;
precedence left LBRACKET, RBRACKET;
precedence left PP, MM;
precedence left LPAREN, RPAREN;
precedence left ID;
   
	program	::=	program code_part
				|
				code_part
				;

   
	code_part ::= 	EXTERN func:f SEMI
			{: parser.cg.declareFunc(); :}
			|
			EXTERN definition:d SEMI
			{: parser.cg.declareVar(); :}
			|
			TYPEDEF definition:d2 SEMI
			{: parser.cg.declareTypedef_var(); :}
			|
			TYPEDEF STRUCT LQ struct_body:s RQ ID:i SEMI
			{: parser.cg.declareTypedef_struct(i); :}
			|
			STRUCT 
			{:
			parser.cg.structflag = true;
			:}
			ID:i LQ struct_body:s RQ SEMI
			{: 
			parser.cg.struct.setID(i);
			parser.cg.declareStruct();
			:}
			|
			DEFINE:d
			{:
			parser.cg.define.setExp(d);
			parser.cg.define.setID("");
			parser.cg.declareDefine();
			:}
			|
			ConditionKeys
			|
			INCLUDE LESS ID:i1 DOT ID:i2 GREATER 
			{: parser.cg.addDeclaration(new Include(i1+"."+i2)); :}
			| INCLUDE LESS ID:i GREATER
			{: parser.cg.addDeclaration(new Include(i)); :}
			;

	ConditionKeys	::= IFDEF ID:i 
			{:
			ConditionalBlock cb = new ConditionalBlock();
			cb.setID(i);
			if (parser.cg.structflag && !parser.cg.structblock)
			{
				cb.inStruct = true;
				parser.cg.structblock = true;
			}
			parser.cg.conditionalBlocks.push(cb);
			:}   
			| IFNDEF ID:i
			{:
			ConditionalBlock cb = new ConditionalBlock();
			cb.setID(i);
			parser.cg.conditionalBlocks.push(cb);
			:}
			| ELSE 
			{:
			parser.cg.conditionalBlocks.peek().condition = false;
			:}
			| ENDIF
			{:
			parser.cg.declareConditionalBlock();
			:}
			;	


	func	::=	type:e ID:e2 LPAREN 
			{: 
			parser.cg.func.setReturn_type(e);
			parser.cg.func.setID(e2);
			parser.cg.paramsowner = parser.cg.func;
			:}						
			params:p RPAREN
			{: 
			RESULT = e + " " + e2 + "(" + p + ");"; 
			:} 
			;
	

	struct_body	::=	definition SEMI
			{:
			if (parser.cg.structblock)
				parser.cg.addDeclaration(parser.cg.var);
			else
				parser.cg.struct.addMember(parser.cg.var);
		        parser.cg.var = new Variable(); 
			:}
			|
			ConditionKeys
			|
			struct_body ConditionKeys
			|
			struct_body definition SEMI
			{:
			if (parser.cg.structblock)
				parser.cg.addDeclaration(parser.cg.var);
			else
				parser.cg.struct.addMember(parser.cg.var);

		        parser.cg.var = new Variable();  
			:}
			;
	
	definition ::=	type:i ID:i2
			{: 
			parser.cg.var.setType(i);
			parser.cg.var.setID(i2);
			:}
			|
			definition LBRACKET RBRACKET
			{:
			parser.cg.var.addArray(0);
			:}
			| 
			definition LBRACKET NUMBER:n RBRACKET
			{:
			parser.cg.var.addArray(n);
			:}
			|
			type:i7 LPAREN STAR ID:i8 RPAREN LPAREN
			{: 
			parser.cg.var.setType(i7+"*");
			parser.cg.var.setID(i8);
			Function funcp = new Function();
			funcp.setID(i8);
			funcp.setReturn_type(i7+"*");
			parser.cg.params_owners.push(parser.cg.paramsowner);
			parser.cg.paramsowner = funcp;  
			:}
			params:ps RPAREN
			{:
			Function funcp = parser.cg.paramsowner;
			funcp.pointer = true;
			parser.cg.var.setFuncpointer(funcp);
			parser.cg.paramsowner = parser.cg.params_owners.pop();
			:}
			;

	

	params	::=	type: p
			{: 
			parser.cg.paramsowner.pushParam(p);
			:}
			|
			type:p2 COMMA params:ps
			{: 
			parser.cg.paramsowner.pushParam(p2);
			:}
			|
			type:p3 COMMA DOTS
			{:
			parser.cg.paramsowner.pushParam(p3);
			:}
			|
			ident_funcpointer:p4
			{:
			parser.cg.paramsowner.pushParam(p4);
			:}
			|
			ident_funcpointer:p5 COMMA params:ps2
			{: 
			parser.cg.paramsowner.pushParam(p5);
			:}
			|
			;

	ident_funcpointer ::=
			type:p4 LPAREN STAR RPAREN LPAREN 
			{:
			Function funcp = new Function();
			funcp.pointer = true;
			funcp.setReturn_type(p4);
			parser.cg.params_owners.push(parser.cg.paramsowner);
			parser.cg.paramsowner = funcp;  
			:}
			params:ps2 RPAREN
			{:
			Function funcp = parser.cg.paramsowner;
			funcp.pointer = true;
			parser.cg.paramsowner = parser.cg.params_owners.pop();
			RESULT = funcp;
			:}
			;



	c_type ::=	CHAR {: RESULT= "char"; :}| INT {: RESULT= "int"; :}
			| SINT {: RESULT= "short int"; :}| LINT {: RESULT= "long int"; :} 
			| SHORT {: RESULT="short"; :}
			| LONG {: RESULT="long"; :} | LLONG {: RESULT= "long long"; :}| LLINT {: RESULT= "long long int"; :}
			| FLOAT {: RESULT= "float"; :}| DOUBLE {: RESULT= "double"; :}| LDOUBLE {: RESULT= "long double"; :};
			
	pre_type::=	c_type:c {: RESULT= c; :}| ID:i {: RESULT= i; :}
			| STRUCT ID:i {: RESULT= "struct " + i; :}
			| UN_SIGNED:u pre_type:p {: RESULT= u + " " + p; :} 
			| CONST pre_type:p {: RESULT="const " + p; :};
			

	type::=		pre_type:p {: RESULT= p; :}
			| type:t LBRACKET RBRACKET {: RESULT=t + "[]"; :}
			| type:t LBRACKET NUMBER:n RBRACKET {: RESULT=t + "[" + n + "]"; :}
			| type:t STAR {: RESULT=t + "*"; :};

	




