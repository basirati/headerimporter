
import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:
   
	public CodeGenerator cg = new CodeGenerator();

    public void report_error(String message, Object info) {
   
       
        StringBuilder m = new StringBuilder("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
     
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {                
                       m.append(" in line "+(s.left+1));   
     
                if (s.right >= 0)                    
                       m.append(", column "+(s.right+1));
            }
        }
   
        m.append(" : "+message);
   
        System.err.println(m);
    }
   
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};
   


terminal		DEFINE, LBRACKET, RBRACKET, ASSIGN, DOT, DOTS, BAR, BARDOT, GREATER, LESS, GG, LL, PREF, MM, PP, GE, LE, AND, OR, NOTEQUAL, EQUAL, COLON, SEMI, PLUS, MINUS, STAR, DIVIDE, COMMA, LPAREN, RPAREN, EXTERN, TYPEDEF, STRUCT, LQ, RQ, PERCENT, HAT, QUESTIONMARK, SHORT, LONG, UN_SIGNED, CONST, AMPERSAND, TILDE, CHAR, INT, SINT, LINT, LLONG, LLINT, FLOAT, DOUBLE, LDOUBLE;

terminal Integer	NUMBER;
terminal String		ID;
   
non terminal Object     def_body, program, code_part, params, defin, st_body, func, ident_funcpointer, exp, func_call, args, Ar2, B2, LogicalS, exp2, exp3, macro, macro_params, def_value, exp3L;
non terminal String	type, pre_type, c_type;

precedence left PP, MM, LPAREN, RPAREN, LBRACKET, DOT, PREF,
	BARDOT, TILDE, STAR, AMPERSAND, DIVIDE, PERCENT, PLUS, MINUS, LL, GG, LESS, LE, GREATER, GE, EQUAL, NOTEQUAL,
	BAR, AND, OR, QUESTIONMARK;
precedence left MINUS, PLUS, ID;

   
	program	::=	program code_part
				|
				code_part
				;

   
	code_part ::= 	EXTERN func:f SEMI
			{: parser.cg.declareFunc(); :}
			|
			EXTERN defin:d SEMI
			{: parser.cg.declareVar(); :}
			|
			TYPEDEF defin:d2 SEMI
			{: parser.cg.declareTypedef_var(); :}
			|
			TYPEDEF STRUCT LQ st_body:s RQ ID:i SEMI
			{: parser.cg.declareTypedef_struct(i); :}
			|
			STRUCT ID:i LQ st_body:s RQ SEMI
			{: 
			parser.cg.struct.setName(i);
			parser.cg.declareStruct(); 
			:}
			|
			DEFINE def_body
			;


	def_body	::=
			ID:i def_value:v
			{: 
			def_expr dx = new def_expr();
			dx.ID = i;
			dx.exp = v;
			parser.cg.defines.add(dx);
			:}
			|
			ID macro exp3 
			|
			ID:i STRUCT ID:v
			{:
			def_expr dx = new def_expr();
			dx.ID = i;
			dx.exp = v;
			dx.isStruct = true;
			parser.cg.defines.add(dx);
			:}
			;
	def_value ::=	NUMBER:n {: RESULT=n; :} | PLUS def_value:d {: RESULT= "+" + d; :} | MINUS def_value:d {: RESULT= "-"+d; :}
			| AMPERSAND def_value:d {: RESULT= "&"+d; :}| STAR def_value:d {: RESULT= "*"+d; :}
			| BARDOT def_value:d {: RESULT= "!"+d; :}| LPAREN def_value:d RPAREN {: RESULT= "("+d+")"; :};

	
	exp ::=		NUMBER:n {: RESULT= n; :}| ID:i {: RESULT= i; :}| func_call:f {: RESULT= f; :}
			| exp:e LBRACKET exp2:e2 RBRACKET {: RESULT= e+"["+e2+"]" :}| exp:e DOT func_call:f {: RESULT= e+"."+f; :} 
			| exp:e DOT ID:i {: RESULT= e+"."+i; :}
			| exp:e PREF func_call:f {: RESULT= e+"->"+f; :}| exp:e PREF ID:i {: RESULT= e+"->"+f; :}
			| exp:e MM {: RESULT= e+"--"; :} | exp:e PP {: RESULT= e+"++"; :} 
			| LPAREN exp:e RPAREN {: RESULT= "("+e+")"; :};

	exp2 ::=	MINUS exp2 | LPAREN MINUS exp2 RPAREN| PLUS exp2 | LPAREN PLUS exp2 RPAREN 
			| PP exp2 | LPAREN PP exp2 RPAREN | MM exp2 | LPAREN MM exp2 RPAREN 
			| STAR exp2 | LPAREN STAR exp2 RPAREN | AMPERSAND exp2 | LPAREN AMPERSAND exp2 RPAREN
			| TILDE exp2 | LPAREN TILDE exp2 RPAREN | exp;
	
	exp3L ::=	LPAREN exp2 Ar2 exp3 RPAREN
			| LPAREN exp2 B2 exp3 RPAREN
			| LPAREN exp2 LogicalS exp2 QUESTIONMARK exp3 COLON exp3 RPAREN
			| LPAREN BARDOT exp2 QUESTIONMARK exp3 COLON exp3 RPAREN
			| LPAREN exp2 QUESTIONMARK exp3 COLON exp3 RPAREN;

	exp3 ::=	exp2 Ar2 exp3 | LPAREN exp2 Ar2 exp3 RPAREN
			| exp2 B2 exp3 | LPAREN exp2 B2 exp3 RPAREN
			| exp2 LogicalS exp3 | | LPAREN exp2 LogicalS exp3 RPAREN
			| exp3 LogicalS exp3L QUESTIONMARK exp3 COLON exp3 | LPAREN exp3 LogicalS exp3L QUESTIONMARK exp3 COLON exp3 RPAREN
			| exp3 LogicalS exp2 QUESTIONMARK exp3 COLON exp3 | LPAREN exp3 LogicalS exp2 QUESTIONMARK exp3 COLON exp3 RPAREN
			| BARDOT exp2 QUESTIONMARK exp3 COLON exp3 | LPAREN BARDOT exp2 QUESTIONMARK exp3 COLON exp3 RPAREN
			| exp3 QUESTIONMARK exp3 COLON exp3 | LPAREN exp3 QUESTIONMARK exp3 COLON exp3 RPAREN
			| TILDE exp3L | AMPERSAND exp3L | STAR exp3L | MM exp3L | PP exp3L | PLUS exp3L | MINUS exp3L
			|exp2;


	Ar2 ::=		ASSIGN | DIVIDE | PERCENT | PLUS | MINUS;
	B2 ::=		LL | GG | HAT | BAR | AMPERSAND;
	LogicalS ::=	LESS | LE | GREATER | GE | EQUAL | NOTEQUAL | AND | OR; 
	func_call ::=	ID LPAREN args RPAREN | ID LPAREN RPAREN;
	args ::=	args COMMA exp3| exp3;

	macro_params ::=macro_params COMMA ID | ID;		
	macro ::=	LPAREN macro_params RPAREN | LPAREN RPAREN;

	func	::=	type:e ID:e2 LPAREN 
			{: 
			parser.cg.func.setReturn_type(e);
			parser.cg.func.setID(e2);
			parser.cg.paramsowner = parser.cg.func;
			:}						
			params:p RPAREN
			{: 
			RESULT = e + " " + e2 + "(" + p + ");"; 
			:} 
			;
	

	st_body	::=	defin SEMI
			{:
			parser.cg.struct.addMember(parser.cg.var);
		        parser.cg.var = new var_decl(); 
			:}
			|
			st_body:s defin SEMI
			{:
			parser.cg.struct.addMember(parser.cg.var);
		        parser.cg.var = new var_decl();  
			:}
			;
	
	defin ::=	type:i ID:i2
			{: 
			parser.cg.var.setType(i);
			parser.cg.var.setID(i2);
			:}
			|
			defin LBRACKET RBRACKET
			{:
			parser.cg.var.addArray(0);
			:}
			| 
			defin LBRACKET NUMBER:n RBRACKET
			{:
			parser.cg.var.addArray(n);
			:}
			|
			type:i7 LPAREN STAR ID:i8 RPAREN LPAREN
			{: 
			parser.cg.var.setType(i7+"*");
			parser.cg.var.setID(i8);
			func_decl funcp = new func_decl();
			funcp.setID(i8);
			funcp.setReturn_type(i7+"*");
			parser.cg.params_owners.push(parser.cg.paramsowner);
			parser.cg.paramsowner = funcp;  
			:}
			params:ps RPAREN
			{:
			func_decl funcp = parser.cg.paramsowner;
			funcp.pointer = true;
			parser.cg.var.setFuncpointer(funcp);
			parser.cg.paramsowner = parser.cg.params_owners.pop();
			:}
			;

	

	params	::=	type: p
			{: 
			parser.cg.paramsowner.pushParam(p);
			:}
			|
			type:p2 COMMA params:ps
			{: 
			parser.cg.paramsowner.pushParam(p2);
			:}
			|
			type:p3 COMMA DOTS
			{:
			parser.cg.paramsowner.pushParam(p3);
			:}
			|
			ident_funcpointer:p4
			{:
			parser.cg.paramsowner.pushParam(p4);
			:}
			|
			ident_funcpointer:p5 COMMA params:ps2
			{: 
			parser.cg.paramsowner.pushParam(p5);
			:}
			|
			;

	ident_funcpointer ::=
			type:p4 LPAREN STAR RPAREN LPAREN 
			{:
			func_decl funcp = new func_decl();
			funcp.pointer = true;
			funcp.setReturn_type(p4);
			parser.cg.params_owners.push(parser.cg.paramsowner);
			parser.cg.paramsowner = funcp;  
			:}
			params:ps2 RPAREN
			{:
			func_decl funcp = parser.cg.paramsowner;
			funcp.pointer = true;
			parser.cg.paramsowner = parser.cg.params_owners.pop();
			RESULT = funcp;
			:}
			;



	c_type ::=	CHAR {: RESULT= "char"; :}| INT {: RESULT= "int"; :}
			| SINT {: RESULT= "short int"; :}| LINT {: RESULT= "long int"; :} 
			| SHORT {: RESULT="short"; :}
			| LONG {: RESULT="long"; :} | LLONG {: RESULT= "long long"; :}| LLINT {: RESULT= "long long int"; :}
			| FLOAT {: RESULT= "float"; :}| DOUBLE {: RESULT= "double"; :}| LDOUBLE {: RESULT= "long double"; :};
			
	pre_type::=	c_type:c {: RESULT= c; :}| ID:i {: RESULT= i; :}
			| STRUCT ID:i {: RESULT= "struct " + i; :}
			| UN_SIGNED:u pre_type:p {: RESULT= u + " " + p; :} 
			| CONST pre_type:p {: RESULT="const " + p; :};
			

	type::=		pre_type:p {: RESULT= p; :}
			| type:t LBRACKET RBRACKET {: RESULT=t + "[]"; :}
			| type:t LBRACKET NUMBER:n RBRACKET {: RESULT=t + "[" + n + "]"; :}
			| type:t STAR {: RESULT=t + "*"; :};

	




