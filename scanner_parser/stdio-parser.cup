
import java_cup.runtime.*;
import java.util.ArrayList;

parser code {:
   
	public CodeGenerator cg = new CodeGenerator();

    public void report_error(String message, Object info) {
   
       
        StringBuilder m = new StringBuilder("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
     
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {                
                       m.append(" in line "+(s.left+1));   
     
                if (s.right >= 0)                    
                       m.append(", column "+(s.right+1));
            }
        }
   
        m.append(" : "+message);
   
        System.err.println(m);
    }
   
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};
   


terminal		DEFINE, LBRACKET, RBRACKET, DOTS, SEMI, PRE_ID, PLUS, MINUS, STAR, DIVIDE, COMMA, LPAREN, RPAREN, EXTERN, TYPEDEF, STRUCT, LQ, RQ, UNDERSCORE, SHORT, LONG, UN_SIGNED, CONST, AMPERSAND;

terminal Integer	NUMBER;
terminal String		ID;
   
non terminal Object     def_body, program, code_part, params, value, defin, st_body, func, ident_funcpointer;
non terminal Integer	val_int;
non terminal String	type, pre_type, val_str;
   
	program	::=	program code_part
				|
				code_part
				;

   
	code_part ::= 	EXTERN func:f SEMI
			{: parser.cg.declareFunc(); :}
			|
			EXTERN defin:d SEMI
			{: parser.cg.declareVar(); :}
			|
			TYPEDEF defin:d2 SEMI
			{: parser.cg.declareTypedef_var(); :}
			|
			TYPEDEF STRUCT LQ st_body:s RQ ID:i SEMI
			{: parser.cg.declareTypedef_struct(i); :}
			|
			STRUCT ID:i LQ st_body:s RQ SEMI
			{: 
			parser.cg.struct.setName(i);
			parser.cg.declareStruct(); 
			:}
			|
			DEFINE def_body
			;


	def_body	::=	ID:i value:v
			{:
			def_expr dx = new def_expr();
			dx.ID = i;
			dx.exp = v;
			parser.cg.defines.add(dx);
			:}
			|
			ID:i STRUCT val_str:v
			{:
			def_expr dx = new def_expr();
			dx.ID = i;
			dx.exp = v;
			dx.isStruct = true;
			parser.cg.defines.add(dx);
			:}
			;

	

	func	::=	type:e ID:e2 LPAREN 
			{: 
			parser.cg.func.setReturn_type(e);
			parser.cg.func.setID(e2);
			parser.cg.paramsowner = parser.cg.func;
			:}						
			params:p RPAREN
			{: 
			RESULT = e + " " + e2 + "(" + p + ");"; 
			:} 
			;
	

	st_body	::=	defin SEMI
			{:
			parser.cg.struct.addMember(parser.cg.var);
		        parser.cg.var = new var_decl(); 
			:}
			|
			st_body:s defin SEMI
			{:
			parser.cg.struct.addMember(parser.cg.var);
		        parser.cg.var = new var_decl();  
			:}
			;
	
	defin ::=	type:i ID:i2
			{: 
			parser.cg.var.setType(i);
			parser.cg.var.setID(i2);
			:}
			|
			defin LBRACKET RBRACKET
			{:
			parser.cg.var.addArray(0);
			:}
			| 
			defin LBRACKET NUMBER:n RBRACKET
			{:
			parser.cg.var.addArray(n);
			:}
			|
			type:i7 LPAREN STAR ID:i8 RPAREN LPAREN
			{: 
			parser.cg.var.setType(i7+"*");
			parser.cg.var.setID(i8);
			func_decl funcp = new func_decl();
			funcp.setID(i8);
			funcp.setReturn_type(i7+"*");
			parser.cg.params_owners.push(parser.cg.paramsowner);
			parser.cg.paramsowner = funcp;  
			:}
			params:ps RPAREN
			{:
			func_decl funcp = parser.cg.paramsowner;
			funcp.pointer = true;
			parser.cg.var.setFuncpointer(funcp);
			parser.cg.paramsowner = parser.cg.params_owners.pop();
			:}
			;

	


	value	::=	val_str:v
			{: RESULT = v; :}
			|
			val_int:v
			{: RESULT = v; :}
			;

	val_str	::=	ID:i
			{: RESULT = i; :}
			;
			
	val_int	::=	NUMBER:n
			{: RESULT = n; :}
			|
			LPAREN val_int:v RPAREN
			{: RESULT = v; :}
			|
			MINUS val_int:v
			{: RESULT = -v; :}
			;
	

	params	::=	type: p
			{: 
			parser.cg.paramsowner.pushParam(p);
			:}
			|
			type:p2 COMMA params:ps
			{: 
			parser.cg.paramsowner.pushParam(p2);
			:}
			|
			type:p3 COMMA DOTS
			{:
			parser.cg.paramsowner.pushParam(p3);
			:}
			|
			ident_funcpointer:p4
			{:
			parser.cg.paramsowner.pushParam(p4);
			:}
			|
			ident_funcpointer:p5 COMMA params:ps2
			{: 
			parser.cg.paramsowner.pushParam(p5);
			:}
			|
			;

	ident_funcpointer ::=
			type:p4 LPAREN STAR RPAREN LPAREN 
			{:
			func_decl funcp = new func_decl();
			funcp.pointer = true;
			funcp.setReturn_type(p4);
			parser.cg.params_owners.push(parser.cg.paramsowner);
			parser.cg.paramsowner = funcp;  
			:}
			params:ps2 RPAREN
			{:
			func_decl funcp = parser.cg.paramsowner;
			funcp.pointer = true;
			parser.cg.paramsowner = parser.cg.params_owners.pop();
			RESULT = funcp;
			:}
			;



	pre_type::=	ID:i {: RESULT=i; :}
			| SHORT {: RESULT="short"; :}
			| LONG {: RESULT="long"; :}
			| LONG LONG {: RESULT="long long"; :}
			| STRUCT ID:i {: RESULT= "struct " + i; :}
			| UN_SIGNED pre_type:p {: RESULT="signed" + " " + p; :} 
			| CONST pre_type:p {: RESULT="const" + p; :} ;

	type	::=	pre_type:p {: RESULT=p; :}
			| type:t LBRACKET RBRACKET {: RESULT=t + "[]"; :}
			| type:t LBRACKET NUMBER:n RBRACKET {: RESULT=t + "[" + n + "]"; :}
			| type:t STAR {: RESULT=t + "*"; :};
	




